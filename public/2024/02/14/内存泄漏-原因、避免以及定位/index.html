<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>内存泄漏-原因、避免以及定位 | SteveZhang博客</title><meta name="author" content="张龙"><meta name="copyright" content="张龙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="你好，我是雨乐！ 作为C&#x2F;C++开发人员，内存泄漏是最容易遇到的问题之一，这是由C&#x2F;C++语言的特性引起的。C&#x2F;C++语言与其他语言不同，需要开发者去申请和释放内存，即需要开发者去管理内存，如果内存使用不当，就容易造成段错误(segment fault)或者内存泄漏(memory leak)。 今天，借助此文，分析下项目中经常遇到的导致内存泄漏的原因，以及如何避免和定">
<meta property="og:type" content="article">
<meta property="og:title" content="内存泄漏-原因、避免以及定位">
<meta property="og:url" content="http://example.com/2024/02/14/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E5%8E%9F%E5%9B%A0%E3%80%81%E9%81%BF%E5%85%8D%E4%BB%A5%E5%8F%8A%E5%AE%9A%E4%BD%8D/index.html">
<meta property="og:site_name" content="SteveZhang博客">
<meta property="og:description" content="你好，我是雨乐！ 作为C&#x2F;C++开发人员，内存泄漏是最容易遇到的问题之一，这是由C&#x2F;C++语言的特性引起的。C&#x2F;C++语言与其他语言不同，需要开发者去申请和释放内存，即需要开发者去管理内存，如果内存使用不当，就容易造成段错误(segment fault)或者内存泄漏(memory leak)。 今天，借助此文，分析下项目中经常遇到的导致内存泄漏的原因，以及如何避免和定">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-02-14T11:16:34.000Z">
<meta property="article:modified_time" content="2024-02-14T11:56:13.900Z">
<meta property="article:author" content="张龙">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/02/14/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E5%8E%9F%E5%9B%A0%E3%80%81%E9%81%BF%E5%85%8D%E4%BB%A5%E5%8F%8A%E5%AE%9A%E4%BD%8D/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '内存泄漏-原因、避免以及定位',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-14 19:56:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SteveZhang博客"><span class="site-name">SteveZhang博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">内存泄漏-原因、避免以及定位</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-14T11:16:34.000Z" title="发表于 2024-02-14 19:16:34">2024-02-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-14T11:56:13.900Z" title="更新于 2024-02-14 19:56:13">2024-02-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="内存泄漏-原因、避免以及定位"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>你好，我是雨乐！</p>
<p>作为C&#x2F;C++开发人员，内存泄漏是最容易遇到的问题之一，这是由C&#x2F;C++语言的特性引起的。C&#x2F;C++语言与其他语言不同，需要开发者去申请和释放内存，即需要开发者去管理内存，如果内存使用不当，就容易造成<code>段错误(segment fault)</code>或者<code>内存泄漏(memory leak)</code>。</p>
<p>今天，借助此文，分析下项目中经常遇到的导致内存泄漏的原因，以及如何避免和定位内存泄漏。</p>
<p>主要内容如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjWeJLlyCSiclCvNaCbPymAtVLlSNPIkngt4OKib9zfWwt7rMDx4iaiaNMYhRPngGZZsYqlOLLpaXcbMA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>C&#x2F;C++语言中，内存的分配与回收都是由开发人员在编写代码时主动完成的，好处是内存管理的开销较小，程序拥有更高的执行效率；弊端是依赖于开发者的水平，随着代码规模的扩大，极容易遗漏释放内存的步骤，或者一些不规范的编程可能会使程序具有安全隐患。如果对内存管理不当，可能导致程序中存在内存缺陷，甚至会在运行时产生内存故障错误。</p>
<p>内存泄漏是各类缺陷中十分棘手的一种，对系统的稳定运行威胁较大。当动态分配的内存在程序结束之前没有被回收时，则发生了内存泄漏。由于系统软件，如操作系统、编译器、开发环境等都是由C&#x2F;C++语言实现的，不可避免地存在内存泄漏缺陷，特别是一些在服务器上长期运行的软件，若存在内存泄漏则会造成严重后果，例如<code>性能下降、程序终止、系统崩溃、无法提供服务</code>等。</p>
<p>所以，本文从<code>原因</code>、<code>避免</code>以及<code>定位</code>几个方面去深入讲解，希望能给大家带来帮助。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<p>当我们在程序中对原始指针(raw pointer)使用<code>new</code>操作符或者<code>free</code>函数的时候，实际上是在堆上为其分配内存，这个内存指的是RAM，而不是硬盘等永久存储。持续申请而不释放(或者少量释放)内存的应用程序，最终因内存耗尽导致<code>OOM(out of memory)</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjWeJLlyCSiclCvNaCbPymAtgW4nmVJ7eHUZgITibakd43u2ZUU1o9cicY48XzgHx5uJ2T2gFLIE0M0A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>方便大家理解内存泄漏的危害，举个简单的例子。有一个宾馆，共有100间房间，顾客每次都是在前台进行登记，然后拿到房间钥匙。如果有些顾客不需要该房间了，既不去前台处登记退房，也不归还钥匙，久而久之，前台处可用房间越来越少，收入也越来越少，濒临倒闭。当程序申请了内存，而不进行归还，久而久之，可用内存越来越少，OS就会进行自我保护，杀掉该进程，这就是我们常说的<code>OOM(out of memory)</code>。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>内存泄漏分为以下两类：</p>
<ul>
<li>堆内存泄漏：我们经常说的内存泄漏就是堆内存泄漏，在堆上申请了资源，在结束使用的时候，没有释放归还给OS，从而导致该块内存永远不会被再次使用</li>
<li>资源泄漏：通常指的是系统资源，比如socket，文件描述符等，因为这些在系统中都是有限制的，如果创建了而不归还，久而久之，就会耗尽资源，导致其他程序不可用</li>
</ul>
<p>本文主要分析堆内存泄漏，所以后面的内存泄漏均指的是<code>堆内存泄漏</code>。</p>
<h2 id="根源"><a href="#根源" class="headerlink" title="根源"></a>根源</h2><p>内存泄漏，主要指的是在堆(heap)上申请的动态内存泄漏，或者说是指针指向的内存块忘了被释放，导致该块内存不能再被申请重新使用。</p>
<p>之前在知乎上看了一句话，指针是C的精髓，也是初学者的一个坎。换句话说，内存管理是C的精髓，C&#x2F;C++可以直接跟OS打交道，从性能角度出发，开发者可以根据自己的实际使用场景灵活进行内存分配和释放。虽然在C++中自C++11引入了smart pointer，虽然很大程度上能够避免使用裸指针，但仍然不能完全避免，最重要的一个原因是你不能保证组内其他人不适用指针，更不能保证合作部门不使用指针。</p>
<p>那么为什么C&#x2F;C++中会存在指针呢？</p>
<p>这就得从进程的内存布局说起。</p>
<h3 id="进程内存布局"><a href="#进程内存布局" class="headerlink" title="进程内存布局"></a>进程内存布局</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjWeJLlyCSiclCvNaCbPymAtBoa7nPzXRknS6wzIkptqGVoKyzMyvtgcpYSwgvMvpWQCnKrMuqy8ww/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>上图为32位进程的内存布局，从上图中主要包含以下几个块：</p>
<ul>
<li><p>内核空间：供内核使用，存放的是内核代码和数据</p>
</li>
<li><p>stack：这就是我们经常所说的栈，用来存储自动变量(automatic variable)</p>
</li>
<li><p>mmap:也成为内存映射，用来在进程虚拟内存地址空间中分配地址空间，创建和物理内存的映射关系</p>
</li>
<li><p>heap:就是我们常说的堆，动态内存的分配都是在堆上</p>
</li>
<li><p>bss:包含所有未初始化的全局和静态变量，此段中的所有变量都由0或者空指针初始化，程序加载器在加载程序时为BSS段分配内存</p>
</li>
<li><p>data:初始化的数据块</p>
</li>
<li><ul>
<li>包含显式初始化的全局变量和静态变量</li>
<li>此段的大小由程序源代码中值的大小决定，在运行时不会更改</li>
<li>它具有读写权限，因此可以在运行时更改此段的变量值</li>
<li>该段可进一步分为初始化只读区和初始化读写区</li>
</ul>
</li>
<li><p>text：也称为文本段</p>
</li>
<li><ul>
<li>该段包含已编译程序的二进制文件。</li>
<li>该段是一个只读段，用于防止程序被意外修改</li>
<li>该段是可共享的，因此对于文本编辑器等频繁执行的程序，内存中只需要一个副本</li>
</ul>
</li>
</ul>
<p>由于本文主要讲内存分配相关，所以下面的内容仅涉及到栈(stack)和堆(heap)。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjWeJLlyCSiclCvNaCbPymAtcpUSFPrvYG4LR9COkJu6pAUnr4nJmWy7or2r8IWQB0YazBteoPOSkg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈一块连续的内存块，栈上的内存分配就是在这一块连续内存块上进行操作的。编译器在编译的时候，就已经知道要分配的内存大小，当调用函数时候，其内部的遍历都会在栈上分配内存；当结束函数调用时候，内部变量就会被释放，进而将内存归还给栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Object &#123;</span><br><span class="line">  public:</span><br><span class="line">    Object() = default;</span><br><span class="line">    // ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void fun() &#123;</span><br><span class="line">  Object obj;</span><br><span class="line">  </span><br><span class="line">  // do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，obj就是在栈上进行分配，当出了fun作用域的时候，会自动调用Object的析构函数对其进行释放。</p>
<p>前面有提到，局部变量会在作用域（如函数作用域、块作用域等）结束后析构、释放内存。因为分配和释放的次序是刚好完全相反的，所以可用到堆栈先进后出（first-in-last-out, FILO）的特性，而 C++ 语言的实现一般也会使用到调用堆栈（call stack）来分配局部变量（但非标准的要求）。</p>
<p>因为栈上内存分配和释放，是一个进栈和出栈的过程(对于编译器只是一个指令)，所以相比于堆上的内存分配，栈要快的多。</p>
<p>虽然栈的访问速度要快于堆，每个线程都有一个自己的栈，<code>栈上的对象是不能跨线程访问的</code>，这就决定了栈空间大小是有限制的，如果栈空间过大，那么在大型程序中几十乃至上百个线程，光栈空间就消耗了RAM，这就导致heap的可用空间变小，影响程序正常运行。</p>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>在Linux系统上，可用通过如下命令来查看栈大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -s</span><br><span class="line">10240</span><br></pre></td></tr></table></figure>

<p>在笔者的机器上，执行上述命令输出结果是10240(KB)即10m，可以通过shell命令修改栈大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -s 102400</span><br></pre></td></tr></table></figure>

<p>通过如上命令，可以将栈空间临时修改为100m，可以通过下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/security/limits.conf</span><br></pre></td></tr></table></figure>

<h4 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h4><h5 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h5><p>静态分配由编译器完成，假如局部变量以及函数参数等，都在编译期就分配好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun() &#123;</span><br><span class="line">  int a[10];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，a占<code>10 * sizeof(int)</code>个字节，在编译的时候直接计算好了，运行的时候，直接进栈出栈。</p>
<h5 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h5><p>可能很多人认为只有堆上才会存在动态分配，在栈上只可能是静态分配。其实，这个观点是错的，栈上也<code>支持动态分配</code>，该动态分配由alloca()函数进行分配。栈的动态分配和堆是不同的，通过alloca()函数分配的内存由编译器进行释放，无需手动操作。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>分配速度快：分配大小由编译器在编译期完成</li>
<li>不会产生内存碎片：栈内存分配是连续的，以FILO的方式进栈和出栈</li>
<li>大小受限：栈的大小依赖于操作系统</li>
<li>访问受限：只能在当前函数或者作用域内进行访问</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆（heap）是一种内存管理方式。内存管理对操作系统来说是一件非常复杂的事情，因为首先内存容量很大，其次就是内存需求在时间和大小块上没有规律（操作系统上运行着几十甚至几百个进程，这些进程可能随时都会申请或者是释放内存，并且申请和释放的内存块大小是随意的）。</p>
<p>堆这种内存管理方式的特点就是自由（<code>随时申请</code>、<code>随时释放</code>、<code>大小块随意</code>）。堆内存是操作系统划归给堆管理器（操作系统中的一段代码，属于操作系统的内存管理单元）来管理的，堆管理器提供了对应的接口_sbrk、_mmap等，只是该接口往往由运行时库(Linux为glibc)进行调用，即也可以说由运行时库进行堆内存管理，运行时库提供了malloc&#x2F;free函数由开发人员调用，进而使用堆内存。</p>
<h4 id="分配方式-1"><a href="#分配方式-1" class="headerlink" title="分配方式"></a>分配方式</h4><p>正如我们所理解的那样，由于是在<code>运行期</code>进行内存分配，分配的大小也在运行期才会知道，所以堆只支持<code>动态分配</code>，内存申请和释放的行为由开发者自行操作，这就很容易造成我们说的内存泄漏。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>变量可以在<code>进程</code>范围内访问，即<code>进程内的所有线程</code>都可以访问该变量</li>
<li>没有内存大小限制，这个其实是相对的，只是相对于栈大小来说没有限制，其实最终还是受限于RAM</li>
<li>相对栈来说访问比较慢</li>
<li>内存碎片</li>
<li>由开发者管理内存，即内存的申请和释放都由开发人员来操作</li>
</ul>
<h3 id="堆与栈区别"><a href="#堆与栈区别" class="headerlink" title="堆与栈区别"></a>堆与栈区别</h3><p>理解堆和栈的区别，对我们开发过程中会非常有用，结合上面的内容，总结下二者的区别。</p>
<p>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak</p>
<ul>
<li><p>空间大小不同</p>
</li>
<li><ul>
<li>一般来讲在 32 位系统下，堆内存可以达到3G的空间，从这个角度来看堆内存几乎是没有什么限制的。</li>
<li>对于栈来讲，一般都是有一定的空间大小的，一般依赖于操作系统(也可以人工设置)</li>
</ul>
</li>
<li><p>能否产生碎片不同</p>
</li>
<li><ul>
<li>对于堆来讲，频繁的内存分配和释放势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。</li>
<li>对于栈来讲，内存都是连续的，申请和释放都是指令移动，类似于数据结构中的<code>进栈和出栈</code></li>
</ul>
</li>
<li><p><strong>增长方向不同</strong></p>
</li>
<li><ul>
<li>对于堆来讲，生长方向是<code>向上</code>的，也就是向着<code>内存地址增加</code>的方向</li>
<li>对于栈来讲，它的生长方向是<code>向下</code>的，是向着<code>内存地址减小</code>的方向增长</li>
</ul>
</li>
<li><p>分配方式不同</p>
</li>
<li><ul>
<li>堆都是动态分配的，比如我们常见的malloc&#x2F;new；而栈则有静态分配和动态分配两种。</li>
<li>静态分配是编译器完成的，比如局部变量的分配，而栈的动态分配则通过alloca()函数完成</li>
<li>二者动态分配是不同的，栈的动态分配的内存由编译器进行释放，而堆上的动态分配的内存则必须由开发人自行释放</li>
</ul>
</li>
<li><p>分配效率不同</p>
</li>
<li><ul>
<li>栈有操作系统分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高</li>
<li>堆内存的申请和释放专门有运行时库提供的函数，里面涉及复杂的逻辑，申请和释放效率低于栈</li>
</ul>
</li>
</ul>
<blockquote>
<p>截止到这里，栈和堆的基本特性以及各自的优缺点、使用场景已经分析完成，在这里给开发者一个<code>建议</code>，能使用栈的时候，就尽量使用栈，一方面是因为效率高于堆，另一方面内存的申请和释放由编译器完成，这样就避免了很多问题。</p>
</blockquote>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>终于到了这一小节，其实，上面讲的那么多，都是为这一小节做铺垫。</p>
<p>在前面的内容中，我们对比了栈和堆，虽然栈效率比较高，且不存在内存泄漏、内存碎片等，但是由于其本身的局限性(不能多线程、大小受限)，所以在很多时候，还是需要在堆上进行内存。</p>
<p>我们先看一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> *p;</span><br><span class="line">  p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码很简单，有两个变量a和p，类型分别为int和int *，其中，a和p存储在栈上，p的值为在堆上的某块地址(在上述代码中，p的值为0x1c66010)，上述代码布局如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjWeJLlyCSiclCvNaCbPymAtjSdOibLNkaic7NDQnVLQUefLb3neialdkuF1iauibYMgSUeWIyv8GOHPmYg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="产生方式"><a href="#产生方式" class="headerlink" title="产生方式"></a>产生方式</h2><p>以产生的方式来分类，内存泄漏可以分为四类:</p>
<ul>
<li>常发性内存泄漏</li>
<li>偶发性内存泄漏</li>
<li>一次性内存泄漏</li>
<li>隐式内存泄漏</li>
</ul>
<h3 id="常发性内存泄漏"><a href="#常发性内存泄漏" class="headerlink" title="常发性内存泄漏"></a>常发性内存泄漏</h3><p>产生内存泄漏的代码或者函数会被多次执行到，在每次执行的时候，都会产生内存泄漏。</p>
<h3 id="偶发性内存泄漏"><a href="#偶发性内存泄漏" class="headerlink" title="偶发性内存泄漏"></a>偶发性内存泄漏</h3><p>与<code>常发性内存泄漏</code>不同的是，偶发性内存泄漏函数只在特定的场景下才会被执行。</p>
<p>笔者在19年的时候，曾经遇到一个这种内存泄漏。有一个函数专门进行价格加密，每次泄漏3个字节，且只有在竞价成功的时候，才会调用此函数进行价格加密，因此泄漏的非常不明显。当时发现这个问题，是上线后的第二天，帮忙排查线上问题，发现内存较上线前上涨了点(大概几百兆的样子)，了解glibc内存分配原理的都清楚，调用delete后，内存不一定会归还给OS，但是本着宁可信其有，不可信其无的心态，决定来分析是否真的存在内存泄漏。</p>
<p>当时用了个比较傻瓜式的方法，通过<code>top</code>命令，将该进程所占的内存输出到本地文件，大概几个小时后，将这些数据导入Excel中，内存占用基本呈一条斜线，所以基本能够确定代码存在内存泄漏，所以就对新上线的这部分代码进行重新<code>review</code>，定位到泄漏点，然后修复，重新上线。</p>
<h3 id="一次性内存泄漏"><a href="#一次性内存泄漏" class="headerlink" title="一次性内存泄漏"></a>一次性内存泄漏</h3><p>这种内存泄漏在程序的生命周期内只会泄漏一次，或者说造成泄漏的代码只会被执行一次。</p>
<p>有的时候，这种可能不算内存泄漏，或者说设计如此。就以笔者现在线上的服务来说，类似于如下这种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">  auto *service = new Service;</span><br><span class="line">  // do sth</span><br><span class="line">  service-&gt;Run();// 服务启动</span><br><span class="line">  service-&gt;Loop(); // 可以理解为一个sleep，目的是使得程序不退出</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种严格意义上，并不算内存泄漏，因为程序是这么设计的，即使程序异常退出，那么整个服务进程也就退出了，当然，在Loop()后面加个delete更好。</p>
<h3 id="隐式内存泄漏"><a href="#隐式内存泄漏" class="headerlink" title="隐式内存泄漏"></a>隐式内存泄漏</h3><p>程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。</p>
<p>比较常见的隐式内存泄漏有以下三种：</p>
<ul>
<li>内存碎片：还记得我们之前的那篇文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&mid=2247485953&idx=1&sn=f8cd484607ab07f15247ecde773d2e1c&scene=21#wechat_redirect">深入理解glibc内存管理精髓</a>，程序跑了几天之后，进程就因为OOM导致了退出，就是因为内存碎片导致剩下的内存不能被重新分配导致</li>
<li>即使我们调用了free&#x2F;delete，运行时库不一定会将内存归还OS，具体<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&mid=2247485953&idx=1&sn=f8cd484607ab07f15247ecde773d2e1c&scene=21#wechat_redirect">深入理解glibc内存管理精髓</a></li>
<li>用过STL的知道，STL内部有一个自己的allocator，我们可以当做一个memory poll，当调用vector.clear()时候，内存并不会归还OS，而是放回allocator，其内部根据一定的策略，在特定的时候将内存归还OS，是不是跟glibc原理很像😁</li>
</ul>
<h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><h3 id="未释放"><a href="#未释放" class="headerlink" title="未释放"></a>未释放</h3><p>这种是很常见的，比如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> * pBuffer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Do some work */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是非常常见的内存泄漏场景(也可以使用new来进行分配)，我们申请了一块内存，但是在fun函数结束时候没有调用free函数进行内存释放。</p>
<p>在C++开发中，还有一种内存泄漏，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Obj</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">     buffer_ = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ~<span class="built_in">Obj</span>()&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   <span class="type">char</span> *buffer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object obj;</span><br><span class="line">  <span class="comment">// do sth</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码中，析构函数没有释放成员变量buffer_指向的内存，所以在编写析构函数的时候，一定要仔细分析成员变量有没有申请动态内存，如果有，则需要手动释放，我们重新编写了析构函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Object</span>() &#123;</span><br><span class="line">  <span class="keyword">delete</span> buffer_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C&#x2F;C++中，对于普通函数，如果申请了堆资源，请跟进代码的具体场景调用free&#x2F;delete进行资源释放；对于class，如果申请了堆资源，则需要在对应的析构函数中调用free&#x2F;delete进行资源释放。</p>
<h3 id="未匹配"><a href="#未匹配" class="headerlink" title="未匹配"></a>未匹配</h3><p>在C++中，我们经常使用new操作符来进行内存分配，其内部主要做了<code>两件</code>事：</p>
<ol>
<li><strong>通过operator new从堆上申请内存(glibc下，operator new底层调用的是malloc)</strong></li>
<li><strong>调用构造函数(如果操作对象是一个class的话)</strong></li>
</ol>
<p>对应的，使用delete操作符来释放内存，其顺序正好与new相反：</p>
<ol>
<li><strong>调用对象的析构函数(如果操作对象是一个class的话)</strong></li>
<li><strong>通过operator delete释放内存</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span>(<span class="string">&quot;new failed to allocate %zu bytes&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span> size) &#123;</span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span>(<span class="string">&quot;new[] failed to allocate %zu bytes&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr) <span class="keyword">throw</span>() &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了加深多这块的理解，我们举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Test</span>() &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;in Test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// other</span></span><br><span class="line">   ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;in ~Test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test *t = <span class="keyword">new</span> Test;</span><br><span class="line">  <span class="comment">// do sth</span></span><br><span class="line">  <span class="keyword">delete</span> t;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述main函数中，我们使用new 操作符创建一个Test类指针</p>
<ol>
<li>通过operator new申请内存(底层malloc实现)</li>
<li>通过placement new在上述申请的内存块上调用构造函数</li>
<li>调用ptr-&gt;~Test()释放Test对象的成员变量</li>
<li>调用operator delete释放内存</li>
</ol>
<p>上述过程，可以理解为如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Test));</span><br><span class="line">t = <span class="built_in">new</span>(ptr)Test</span><br><span class="line">  </span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line">ptr-&gt;~<span class="built_in">Test</span>();</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure>

<p>好了，上述内容，我们简单的讲解了C++中new和delete操作符的基本实现以及逻辑，那么，我们就简单总结下下产生内存泄漏的几种类型。</p>
<h4 id="new-和-free"><a href="#new-和-free" class="headerlink" title="new 和 free"></a>new 和 free</h4><p>仍然以上面的Test对象为例，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test *t = <span class="keyword">new</span> Test;</span><br><span class="line"><span class="built_in">free</span>(t)</span><br></pre></td></tr></table></figure>

<p>此处会产生内存泄漏，在上面，我们已经分析过，new操作符会先通过operator new分配一块内存，然后在该块内存上调用placement new即调用Test的构造函数。而在上述代码中，只是通过free函数释放了内存，但是没有调用Test的析构函数以释放Test的成员变量，从而引起<code>内存泄漏</code>。</p>
<h4 id="new-和-delete"><a href="#new-和-delete" class="headerlink" title="new[] 和 delete"></a>new[] 和 delete</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test *t = <span class="keyword">new</span> Test [<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// do sth</span></span><br><span class="line">  <span class="keyword">delete</span> t;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们通过new创建了一个Test类型的数组，然后通delete操作符删除该数组，编译并执行，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in Test</span><br><span class="line">in Test</span><br><span class="line">in Test</span><br><span class="line">in Test</span><br><span class="line">in Test</span><br><span class="line">in Test</span><br><span class="line">in Test</span><br><span class="line">in Test</span><br><span class="line">in Test</span><br><span class="line">in Test</span><br><span class="line">in ~Test</span><br></pre></td></tr></table></figure>

<p>从上面输出结果可以看出，调用了10次构造函数，但是只调用了一次析构函数，所以引起了<code>内存泄漏</code>。这是因为调用delete t释放了通过operator new[]申请的内存，即malloc申请的内存块，且只调用了t[0]对象的析构函数，t[1..9]对象的析构函数并没有被调用。</p>
<h3 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a>虚析构</h3><p>记得08年面谷歌的时候，有一道题，面试官问，std::string能否被继承，为什么？</p>
<p>当时没回答上来，后来过了没多久，进行面试复盘的时候，偶然看到继承需要父类析构函数为<code>virtual</code>，才恍然大悟，原来考察点在这块。</p>
<p>下面我们看下std::string的析构函数定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">basic_string</span>() &#123; </span><br><span class="line">  _M_rep()-&gt;_M_dispose(<span class="keyword">this</span>-&gt;<span class="built_in">get_allocator</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块需要特别说明下，std::basic_string是一个模板，而std::string是该模板的一个特化，即std::basic_string。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::basic_string&lt;<span class="type">char</span>&gt; string;</span><br></pre></td></tr></table></figure>

<p>现在我们可以给出这个问题的答案：不能，因为std::string的析构函数不为virtual，这样会引起<code>内存泄漏</code>。</p>
<p>仍然以一个例子来进行证明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>()&#123;</span><br><span class="line">    buffer_ = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;in Base::~Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> []buffer_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span> *buffer_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int Derived::~Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base *base = <span class="keyword">new</span> Derived;</span><br><span class="line">  <span class="keyword">delete</span> base;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in Base::~Base</span><br></pre></td></tr></table></figure>

<p>可见，上述代码并没有调用派生类Derived的析构函数，如果派生类中在堆上申请了资源，那么就会产生<code>内存泄漏</code>。</p>
<p>为了避免因为继承导致的内存泄漏，我们需要将父类的析构函数声明为<code>virtual</code>，代码如下(只列了部分修改代码，其他不变):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~Base() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;in Base::~Base&quot; &lt;&lt; std::endl;</span><br><span class="line">    delete []buffer_;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后重新执行代码，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int Derived::~Derived</span><br><span class="line">in Base::~Base</span><br></pre></td></tr></table></figure>

<p>借助此文，我们再次总结下存在继承情况下，构造函数和析构函数的调用顺序。</p>
<p>派生类对象在创建时构造函数调用顺序：</p>
<ol>
<li>调用父类的构造函数</li>
<li>调用父类成员变量的构造函数</li>
<li>调用派生类本身的构造函数</li>
</ol>
<p>派生类对象在析构时的析构函数调用顺序：</p>
<ol>
<li>执行派生类自身的析构函数</li>
<li>执行派生类成员变量的析构函数</li>
<li>执行父类的析构函数</li>
</ol>
<blockquote>
<p>为了避免存在继承关系时候的内存泄漏，请遵守一条规则：无论派生类有没有申请堆上的资源，请将父类的<code>析构函数声明为virtual</code>。</p>
</blockquote>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>在C++开发中，为了尽可能的避免内存泄漏，自C++11起引入了<code>smart pointer</code>，常见的有shared_ptr、weak_ptr以及unique_ptr等(auto_ptr已经被废弃)，其中weak_ptr是为了解决循环引用而存在，其往往与shared_ptr结合使用。</p>
<p>下面，我们看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Controller &#123;</span><br><span class="line"> public:</span><br><span class="line">  Controller() = default;</span><br><span class="line"></span><br><span class="line">  ~Controller() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;in ~Controller&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class SubController &#123;</span><br><span class="line">   public:</span><br><span class="line">    SubController() = default;</span><br><span class="line"></span><br><span class="line">    ~SubController() &#123;</span><br><span class="line">      std::cout &lt;&lt; &quot;in ~SubController&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;Controller&gt; controller_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;SubController&gt; sub_controller_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  auto controller = std::make_shared&lt;Controller&gt;();</span><br><span class="line">  auto sub_controller = std::make_shared&lt;Controller::SubController&gt;();</span><br><span class="line"></span><br><span class="line">  controller-&gt;sub_controller_ = sub_controller;</span><br><span class="line">  sub_controller-&gt;controller_ = controller;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行上述代码，发现并没有调用Controller和SubController的析构函数，我们尝试着打印下引用计数，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">  auto controller = std::make_shared&lt;Controller&gt;();</span><br><span class="line">  auto sub_controller = std::make_shared&lt;Controller::SubController&gt;();</span><br><span class="line"></span><br><span class="line">  controller-&gt;sub_controller_ = sub_controller;</span><br><span class="line">  sub_controller-&gt;controller_ = controller;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; &quot;controller use_count: &quot; &lt;&lt; controller.use_count() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot;sub_controller use_count: &quot; &lt;&lt; sub_controller.use_count() &lt;&lt; std::endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行之后，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">controller use_count: 2</span><br><span class="line">sub_controller use_count: 2</span><br></pre></td></tr></table></figure>

<p>通过上面输出可以发现，因为引用计数都是2，所以在main函数结束的时候，不会调用controller和sub_controller的析构函数，所以就出现了<code>内存泄漏</code>。</p>
<p>上面产生内存泄漏的原因，就是我们常说的<code>循环引用</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjWeJLlyCSiclCvNaCbPymAt87pv6DVzszw6924YcCibMWs7KSlYSHgbUeyV9Fww3ia5K64iaBWGtTGnQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>为了解决std::shared_ptr循环引用导致的内存泄漏，我们可以使用std::weak_ptr来单面去除上图中的循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Controller &#123;</span><br><span class="line"> public:</span><br><span class="line">  Controller() = default;</span><br><span class="line"></span><br><span class="line">  ~Controller() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;in ~Controller&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class SubController &#123;</span><br><span class="line">   public:</span><br><span class="line">    SubController() = default;</span><br><span class="line"></span><br><span class="line">    ~SubController() &#123;</span><br><span class="line">      std::cout &lt;&lt; &quot;in ~SubController&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::weak_ptr&lt;Controller&gt; controller_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;SubController&gt; sub_controller_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们将SubController类中controller_的类型从std::shared_ptr变成std::weak_ptr，重新编译执行，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">controller use_count: 1</span><br><span class="line">sub_controller use_count: 2</span><br><span class="line">in ~Controller</span><br><span class="line">in ~SubController</span><br></pre></td></tr></table></figure>

<p>从上面结果可以看出，controller和sub_controller均以释放，所以<code>循环引用</code>引起的内存泄漏问题，也得以解决。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjWeJLlyCSiclCvNaCbPymAtLiagles8UEKYDfzj3leiauxgfwRaVED9iaq85OL6RzbbMF0c3k6yTcs1A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可能有人会问，使用std::shared_ptr可以直接访问对应的成员函数，如果是std::weak_ptr的话，怎么访问呢？我们可以使用下面的方式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr controller = controller_.lock();</span><br></pre></td></tr></table></figure>

<p>即在子类SubController中，如果要使用controller调用其对应的函数，就可以使用上面的方式。</p>
<h2 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h2><h3 id="避免在堆上分配"><a href="#避免在堆上分配" class="headerlink" title="避免在堆上分配"></a>避免在堆上分配</h3><p>众所周知，大部分的内存泄漏都是因为在堆上分配引起的，如果我们不在堆上进行分配，就不会存在内存泄漏了(这不废话嘛)，我们可以根据具体的使用场景，如果对象可以在栈上进行分配，就在栈上进行分配，一方面栈的效率远高于堆，另一方面，还能避免内存泄漏，我们何乐而不为呢。</p>
<h3 id="手动释放"><a href="#手动释放" class="headerlink" title="手动释放"></a>手动释放</h3><ul>
<li>对于malloc函数分配的内存，在结束使用的时候，使用free函数进行释放</li>
<li>对于new操作符创建的对象，切记使用delete来进行释放</li>
<li>对于new []创建的对象，使用delete[]来进行释放(使用free或者delete均会造成内存泄漏)</li>
</ul>
<h3 id="避免使用裸指针"><a href="#避免使用裸指针" class="headerlink" title="避免使用裸指针"></a>避免使用裸指针</h3><p>尽可能避免使用裸指针，除非所调用的lib库或者合作部门的接口是裸指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int fun(int *ptr) &#123;// fun 是一个接口或lib函数</span><br><span class="line">  // do sth</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;&#125;</span><br><span class="line">  int a = 1000;</span><br><span class="line">  int *ptr = &amp;a;</span><br><span class="line">  // ...</span><br><span class="line">  fun(ptr);</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的fun函数中，有一个参数ptr,为int *，我们需要根据上下文来分析这个指针是否需要释放，这是一种<code>很不好的设计</code></p>
<h3 id="使用STL中或者自己实现对象"><a href="#使用STL中或者自己实现对象" class="headerlink" title="使用STL中或者自己实现对象"></a>使用STL中或者自己实现对象</h3><p>在C++中，提供了相对完善且可靠的STL供我们使用，所以能用STL的尽可能的避免使用C中的编程方式，比如：</p>
<ul>
<li>使用std::string 替代char *, string类自己会进行内存管理，而且优化的相当不错</li>
<li>使用std::vector或者std::array来替代传统的数组</li>
<li>其它适合使用场景的对象</li>
</ul>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>自C++11开始，STL中引入了智能指针(smart pointer)来动态管理资源，针对使用场景的不同，提供了以下三种智能指针。</p>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>unique_ptr是限制最严格的一种智能指针，用来替代之前的auto_ptr，独享被管理对象指针所有权。当unique_ptr对象被销毁时，会在其析构函数内删除关联的原始指针。</p>
<p>unique_ptr对象分为以下两类：</p>
<ul>
<li><p>unique_ptr该类型的对象关联了单个Type类型的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Type&gt;   p1(new Type); // c++11</span><br><span class="line">auto p1 = std::make_unique&lt;Type&gt;(); // c++14</span><br></pre></td></tr></table></figure>
</li>
<li><p>unique_ptr&lt;Type[]&gt; 该类型的对象关联了多个Type类型指针，即一个对象数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Type[]&gt; p2(new Type[n]()); // c++11</span><br><span class="line">auto p2 = std::make_unique&lt;Type[]&gt;(n); // c++14</span><br></pre></td></tr></table></figure>
</li>
<li><p>不可用被复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; a(new int(0));</span><br><span class="line">unique_ptr&lt;int&gt; b = a;  // 编译错误</span><br><span class="line">unique_ptr&lt;int&gt; b = std::move(a); // 可以通过move语义进行所有权转移</span><br></pre></td></tr></table></figure></li>
</ul>
<p>根据使用场景，可以使用std::unique_ptr来避免内存泄漏，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void fun() &#123;</span><br><span class="line">  unique_ptr&lt;int&gt; a(new int(0));</span><br><span class="line">  // use a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述fun函数结束的时候，会自动调用a的析构函数，从而释放其关联的指针。</p>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>与unique_ptr不同的是，unique_ptr是<code>独占管理权</code>，而shared_ptr则是<code>共享管理权</code>，即多个shared_ptr可以共用同一块关联对象，其内部采用的是引用计数，在拷贝的时候，引用计数+1，而在某个对象退出作用域或者释放的时候，引用计数-1，当引用计数为0的时候，会自动释放其管理的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void fun() &#123;</span><br><span class="line">  std::shared_ptr&lt;Type&gt; a; // a是一个空对象</span><br><span class="line">  &#123;</span><br><span class="line">    std::shared_ptr&lt;Type&gt; b = std::make_shared&lt;Type&gt;(); // 分配资源</span><br><span class="line">    a = b; // 此时引用计数为2</span><br><span class="line">    &#123;</span><br><span class="line">      std::shared_ptr&lt;Type&gt; c = a; // 此时引用计数为3</span><br><span class="line">    &#125; // c退出作用域，此时引用计数为2</span><br><span class="line">  &#125; // b 退出作用域，此时引用计数为1</span><br><span class="line">&#125; // a 退出作用域，引用计数为0，释放对象</span><br></pre></td></tr></table></figure>

<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>weak_ptr的出现，主要是为了解决shared_ptr的<code>循环引用</code>，其主要是与shared_ptr一起来私用。和shared_ptr不同的地方在于，其并不会拥有资源，也就是说不能访问对象所提供的成员函数，不过，可以通过weak_ptr.lock()来产生一个拥有访问权限的shared_ptr。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;Type&gt; a;</span><br><span class="line">&#123;</span><br><span class="line">  std::shared_ptr&lt;Type&gt; b = std::make_shared&lt;Type&gt;();</span><br><span class="line">  a = b</span><br><span class="line">&#125; // b所对应的资源释放</span><br></pre></td></tr></table></figure>

<h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><p><code>RAII</code>是<code>Resource Acquisition is Initialization(资源获取即初始化)</code>的缩写，是C++语言的一种管理资源，避免泄漏的用法。</p>
<p>利用的就是C++构造的对象最终会被销毁的原则。利用C++对象生命周期的概念来控制程序的资源,比如内存,文件句柄,网络连接等。</p>
<p>RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命周期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。</p>
<p>简单地说，就是把资源的使用限制在对象的生命周期之中，自动释放。</p>
<p>举个简单的例子，通常在多线程编程的时候，都会用到std::mutex，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mutex_;</span><br><span class="line"></span><br><span class="line">void fun() &#123;</span><br><span class="line">  mutex_.lock();</span><br><span class="line">  </span><br><span class="line">  if (...) &#123;</span><br><span class="line">    mutex_.unlock();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  mutex_.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果if分支多的话，每个if分支里面都要释放锁，如果一不小心忘记释放，那么就会造成故障，为了解决这个问题，我们使用<code>RAII</code>技术，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mutex_;</span><br><span class="line"></span><br><span class="line">void fun() &#123;</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; guard(mutex_);</span><br><span class="line"></span><br><span class="line">  if (...) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在guard出了fun作用域的时候，会自动调用mutex_.lock()进行释放，避免了很多不必要的问题。</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>在发现程序存在内存泄漏后，往往需要定位泄漏点，而定位这一步往往是最困难的，所以经常为了定位泄漏点，采取各种各样的方案，甭管方案优雅与否，毕竟<code>管他白猫黑猫，抓住老鼠才是好猫</code>，所以在本节，简单说下笔者这么多年定位泄漏点的方案，有些比较邪门歪道，您就随便看看就行😃。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>这种方案的核心思想，就是在每次分配内存的时候，打印指针地址，在释放内存的时候，打印内存地址，这样在程序结束的时候，通过分配和释放的差，如果分配的条数大于释放的条数，那么基本就能确定程序存在内存泄漏，然后根据日志进行详细分析和定位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char * fun() &#123;</span><br><span class="line">  char *p = (char*)malloc(20);</span><br><span class="line">  printf(&quot;%s, %d, address is: %p&quot;, __FILE__, __LINE__, p);</span><br><span class="line">  // do sth</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  fun();</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>统计方案可以理解为日志方案的一种特殊实现，其主要原理是在分配的时候，统计分配次数，在释放的时候，则是统计释放的次数，这样在程序结束前判断这俩值是否一致，就能判断出是否存在内存泄漏。</p>
<p>此方法可帮助跟踪已分配内存的状态。为了实现这个方案，需要创建三个自定义函数，一个用于内存分配，第二个用于内存释放，最后一个用于检查内存泄漏。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static unsigned int allocated  = 0;</span><br><span class="line">static unsigned int deallocated  = 0;</span><br><span class="line">void *Memory_Allocate (size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr = NULL;</span><br><span class="line">    ptr = malloc(size);</span><br><span class="line">    if (NULL != ptr) &#123;</span><br><span class="line">        ++allocated;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //Log error</span><br><span class="line">    &#125;</span><br><span class="line">    return ptr;</span><br><span class="line">&#125;</span><br><span class="line">void Memory_Deallocate (void *ptr) &#123;</span><br><span class="line">    if(pvHandle != NULL) &#123;</span><br><span class="line">        free(ptr);</span><br><span class="line">        ++deallocated;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Check_Memory_Leak(void) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    if (allocated != deallocated) &#123;</span><br><span class="line">        //Log error</span><br><span class="line">        ret = MEMORY_LEAK;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ret = OK;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>在Linux上比较常用的内存泄漏检测工具是<code>valgrind</code>，所以咱们就以valgrind为工具，进行检测。</p>
<p>我们首先看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void func (void)&#123;</span><br><span class="line">    char *buff = (char*)malloc(10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)&#123;</span><br><span class="line">    func(); // 产生内存泄漏</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>gcc -g leak.c -o leak</code>命令进行编译</li>
<li>执行<code>valgrind --leak-check=full ./leak</code></li>
</ul>
<p>在上述的命令执行后，会输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">==9652== Memcheck, a memory error detector</span><br><span class="line">==9652== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==9652== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==9652== Command: ./leak</span><br><span class="line">==9652==</span><br><span class="line">==9652==</span><br><span class="line">==9652== HEAP SUMMARY:</span><br><span class="line">==9652==     in use at exit: 10 bytes in 1 blocks</span><br><span class="line">==9652==   total heap usage: 1 allocs, 0 frees, 10 bytes allocated</span><br><span class="line">==9652==</span><br><span class="line">==9652== 10 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">==9652==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)</span><br><span class="line">==9652==    by 0x40052E: func (leak.c:4)</span><br><span class="line">==9652==    by 0x40053D: main (leak.c:8)</span><br><span class="line">==9652==</span><br><span class="line">==9652== LEAK SUMMARY:</span><br><span class="line">==9652==    definitely lost: 10 bytes in 1 blocks</span><br><span class="line">==9652==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==9652==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==9652==    still reachable: 0 bytes in 0 blocks</span><br><span class="line">==9652==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==9652==</span><br><span class="line">==9652== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==9652== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>valgrind的检测信息将内存泄漏分为如下几类：</p>
<ul>
<li>definitely lost：确定产生内存泄漏</li>
<li>indirectly lost：间接产生内存泄漏</li>
<li>possibly lost：可能存在内存泄漏</li>
<li>still reachable：即使在程序结束时候，仍然有指针在指向该块内存，常见于全局变量</li>
</ul>
<p>主要上面输出的下面几句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==9652==    by 0x40052E: func (leak.c:4)</span><br><span class="line">==9652==    by 0x40053D: main (leak.c:8)</span><br></pre></td></tr></table></figure>

<p>提示在main函数(leak.c的第8行)fun函数(leak.c的第四行)产生了内存泄漏，通过分析代码，原因定位，问题解决。</p>
<p>valgrind不仅可以检测内存泄漏，还有其他很强大的功能，由于本文以内存泄漏为主，所以其他的功能就不在此赘述了，有兴趣的可以通过<code>valgrind --help</code>来进行查看</p>
<blockquote>
<p>❝</p>
<p>对于Windows下的内存泄漏检测工具，笔者推荐一款轻量级功能却非常强大的工具<code>UMDH</code>，笔者在十二年前，曾经在某外企负责内存泄漏，代码量几百万行，光编译就需要两个小时，尝试了各种工具(免费的和收费的)，最终发现了UMDH，如果你在Windows上进行开发，强烈推荐。</p>
<p>❞</p>
</blockquote>
<h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><p>在C&#x2F;C++开发过程中，内存泄漏是一个非常常见的问题，其影响相对来说远低于coredump等，所以遇到内存泄漏的时候，不用过于着急，大不了重启嘛😁。</p>
<p>在开发过程中遵守下面的规则，基本能90+%避免内存泄漏：</p>
<ul>
<li>良好的编程习惯，只有有malloc&#x2F;new，就得有free&#x2F;delete</li>
<li>尽可能的使用智能指针，智能指针就是为了解决内存泄漏而产生</li>
<li>使用log进行记录</li>
<li>也是最重要的一点，<code>谁申请，谁释放</code></li>
</ul>
<p>对于malloc分配内存，分配失败的时候返回值为NULL，此时程序可以直接退出了，而对于new进行内存分配，其分配失败的时候，是抛出<code>std::bad_alloc</code>，所以为了第一时间发现问题，不要对new异常进行catch，毕竟内存都分配失败了，程序也没有运行的必要了。</p>
<p>如果我们上线后，发现程序存在内存泄漏，如果不严重的话，可以先暂时不管线上，同时进行排查定位；如果线上泄漏比较严重，那么第一时间根据实际情况来决定是否回滚。在定位问题点的时候，可以采用<code>缩小范围法</code>，着重分析这次新增的代码，这样能够有效缩短问题解决的时间。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>C&#x2F;C++之所以复杂、效率高，是因为其灵活性，可用直接访问操作系统API，而正因为其灵活性，就很容易出问题，团队成员必须愿意按照一定的规则来进行开发，有完整的review机制，将问题暴露在上线之前。这样才可以把经历放在业务本身，而不是查找这些问题上，有时候往往一个小问题就能消耗很久的时间去定位解决，所以，一定要有一个<code>良好的开发习惯</code>。</p>
<p>好了，本期的文章就到这，我们下期见。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">张龙</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/14/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E5%8E%9F%E5%9B%A0%E3%80%81%E9%81%BF%E5%85%8D%E4%BB%A5%E5%8F%8A%E5%AE%9A%E4%BD%8D/">http://example.com/2024/02/14/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E5%8E%9F%E5%9B%A0%E3%80%81%E9%81%BF%E5%85%8D%E4%BB%A5%E5%8F%8A%E5%AE%9A%E4%BD%8D/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">SteveZhang博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E4%BD%BF%E7%94%A8%E3%80%81%E9%81%BF%E5%9D%91%E5%92%8C%E5%AE%9E%E7%8E%B0/" title="智能指针-使用、避坑和实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">智能指针-使用、避坑和实现</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/14/CMakeList%E8%AF%AD%E6%B3%95/" title="CMakeList语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CMakeList语法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">张龙</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%BA%90"><span class="toc-number">4.</span> <span class="toc-text">根源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">4.1.</span> <span class="toc-text">进程内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.2.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.2.1.</span> <span class="toc-text">设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">静态分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">动态分配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">4.2.3.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">4.3.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">分配方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">4.3.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.</span> <span class="toc-text">堆与栈区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">4.5.</span> <span class="toc-text">扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">产生方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E5%8F%91%E6%80%A7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">常发性内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%B6%E5%8F%91%E6%80%A7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">偶发性内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">一次性内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">隐式内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-1"><span class="toc-number">6.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E9%87%8A%E6%94%BE"><span class="toc-number">6.1.</span> <span class="toc-text">未释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%8C%B9%E9%85%8D"><span class="toc-number">6.2.</span> <span class="toc-text">未匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E5%92%8C-free"><span class="toc-number">6.2.1.</span> <span class="toc-text">new 和 free</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E5%92%8C-delete"><span class="toc-number">6.2.2.</span> <span class="toc-text">new[] 和 delete</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">虚析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">6.4.</span> <span class="toc-text">循环引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D"><span class="toc-number">7.</span> <span class="toc-text">避免</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D"><span class="toc-number">7.1.</span> <span class="toc-text">避免在堆上分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BE"><span class="toc-number">7.2.</span> <span class="toc-text">手动释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">7.3.</span> <span class="toc-text">避免使用裸指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8STL%E4%B8%AD%E6%88%96%E8%80%85%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.4.</span> <span class="toc-text">使用STL中或者自己实现对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">7.5.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr"><span class="toc-number">7.5.1.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr"><span class="toc-number">7.5.2.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr"><span class="toc-number">7.5.3.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII"><span class="toc-number">7.6.</span> <span class="toc-text">RAII</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D"><span class="toc-number">8.</span> <span class="toc-text">定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">8.1.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1"><span class="toc-number">8.2.</span> <span class="toc-text">统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">8.3.</span> <span class="toc-text">工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88"><span class="toc-number">8.4.</span> <span class="toc-text">经验之谈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">9.</span> <span class="toc-text">结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E4%BD%BF%E7%94%A8%E3%80%81%E9%81%BF%E5%9D%91%E5%92%8C%E5%AE%9E%E7%8E%B0/" title="智能指针-使用、避坑和实现">智能指针-使用、避坑和实现</a><time datetime="2024-02-14T15:38:58.000Z" title="发表于 2024-02-14 23:38:58">2024-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/14/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E5%8E%9F%E5%9B%A0%E3%80%81%E9%81%BF%E5%85%8D%E4%BB%A5%E5%8F%8A%E5%AE%9A%E4%BD%8D/" title="内存泄漏-原因、避免以及定位">内存泄漏-原因、避免以及定位</a><time datetime="2024-02-14T11:16:34.000Z" title="发表于 2024-02-14 19:16:34">2024-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/14/CMakeList%E8%AF%AD%E6%B3%95/" title="CMakeList语法">CMakeList语法</a><time datetime="2024-02-14T07:26:41.000Z" title="发表于 2024-02-14 15:26:41">2024-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/22/SSL%E9%9D%9E%E9%98%BB%E5%A1%9E%E4%B8%8B%E8%AF%BB%E5%86%99%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/" title="SSL非阻塞下读写接口返回值的处理问题">SSL非阻塞下读写接口返回值的处理问题</a><time datetime="2023-10-22T01:13:31.000Z" title="发表于 2023-10-22 09:13:31">2023-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/17/%E5%8D%9A%E5%AD%A6-Linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="博学-Linux文件和系统调用">博学-Linux文件和系统调用</a><time datetime="2023-10-17T07:11:45.000Z" title="发表于 2023-10-17 15:11:45">2023-10-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 张龙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>